#!/usr/bin/env node
/**
 * Home Depot Store Details Scraper (sequential, Playwright + persistent profile)
 *
 * What it does:
 * - Loads data/home-depot-stores.json (generated by scripts/fetch-home-depot-places.js).
 * - For stores missing a real numeric store number or specific nickname, it tries to fetch
 *   the data from Home Depot's StoreFinder API using a real browser context (Edge profile).
 * - Falls back to scraping the store page when a store number is known.
 * - Writes data/home-depot-stores.enriched.json without touching the source file.
 *
 * Why this mirrors fetch-product-data.js:
 * - Uses chromium.launchPersistentContext with a user profile to reuse cookies and bypass bot walls.
 * - Runs sequentially with a small delay to reduce detection risk.
 */

const fs = require("fs")
const path = require("path")
const { chromium } = require("playwright")

const CONFIG = {
  userDataDir: path.join(process.env.LOCALAPPDATA || "", "HD-Scraper-Profile"),
  delayBetween: 1200,
  searchRadius: 50, // miles for StoreFinder search
  headless: false,
}

const DATA_PATH = path.join(process.cwd(), "data", "home-depot-stores.json")
const OUT_PATH = path.join(process.cwd(), "data", "home-depot-stores.enriched.json")

function hasValidStoreNumber(num) {
  if (!num) return false
  return /^\d{1,5}$/.test(String(num).trim())
}

function formatStoreNumber(num) {
  if (!hasValidStoreNumber(num)) return ""
  return String(num).trim().padStart(4, "0")
}

function isSpecificName(name) {
  if (!name) return false
  const trimmed = name.trim()
  if (!trimmed) return false
  return !/^the\s+home\s+depot$/i.test(trimmed)
}

function safeString(value, fallback = "") {
  return typeof value === "string" && value.trim().length > 0 ? value.trim() : fallback
}

function buildStoreUrl(store) {
  const storeName = safeString(store.name, store.city || "Store").replace(/\s+/g, "-")
  const state = safeString(store.state, "GA")
  const city = safeString(store.city, "Atlanta")
  const zip = safeString(store.zip, "")
  const storeNum = hasValidStoreNumber(store.number) ? String(parseInt(store.number, 10)) : ""

  const base = `https://www.homedepot.com/l/${storeName}/${state}/${city}/${zip}`
  return storeNum ? `${base}/${storeNum}` : base
}

async function scrapeStoreFinder(page, store) {
  if (typeof store.lat !== "number" || typeof store.lng !== "number") return null

  return page.evaluate(
    async ({ lat, lng, city, state, radius }) => {
      const params = new URLSearchParams({
        lat: String(lat),
        lon: String(lng),
        radius: String(radius),
      })
      const url = `https://www.homedepot.com/StoreFinder/api/v1/store/search?${params.toString()}`

      const res = await fetch(url, {
        credentials: "include",
        headers: {
          accept: "application/json, text/plain, */*",
          "accept-language": "en-US,en;q=0.9",
        },
      })

      if (!res.ok) {
        throw new Error(`StoreFinder status ${res.status}`)
      }

      const data = await res.json()
      const list = Array.isArray(data)
        ? data
        : Array.isArray(data.stores)
          ? data.stores
          : []

      if (!list.length) return null

      const norm = (val) => (typeof val === "string" ? val.toLowerCase().trim() : "")
      const targetCity = norm(city)
      const targetState = norm(state)

      const match =
        list.find((s) => {
          const c = norm(s.city || s.storeCity)
          const st = norm(s.state || s.storeState)
          return (!targetCity || c === targetCity) && (!targetState || st === targetState)
        }) || list[0]

      if (!match) return null

      const number = match.storeNumber || match.storeId || match.id
      const name = match.storeName || match.name || match.nickname

      return { number, name }
    },
    { lat: store.lat, lng: store.lng, city: store.city, state: store.state, radius: CONFIG.searchRadius },
  )
}

async function scrapeStorePage(page, store) {
  const url = buildStoreUrl(store)

  await page.goto(url, { waitUntil: "domcontentloaded", timeout: 45000 })
  await page.waitForTimeout(2500)

  const isErrorPage = (html) =>
    html.includes("Oops!! Something went wrong") || html.toLowerCase().includes("error page")

  const content = await page.content()
  if (isErrorPage(content)) {
    return null
  }

  return page.evaluate(() => {
    const text = document.body?.innerText || ""
    const title = document.querySelector("title")?.textContent || ""

    const numberMatch = text.match(/Store\s*#\s*(\d{1,5})/i) || title.match(/Store\s*#\s*(\d{1,5})/i)
    const number = numberMatch ? numberMatch[1] : ""

    let name = ""
    const titleMatch = title.match(/^(.*?)(?:\s+-\s+)?(?:The\s+Home\s+Depot|Home\s+Depot)/i)
    if (titleMatch && titleMatch[1]) {
      name = titleMatch[1].trim()
    }

    if (!name) {
      const heading = document.querySelector("h1, h2")
      if (heading?.textContent) {
        name = heading.textContent.replace(/Store\s*#\s*\d{1,5}/i, "").trim()
      }
    }

    return {
      number: number || "",
      name: name || "",
      url: location.href,
    }
  })
}

async function main() {
  if (!fs.existsSync(DATA_PATH)) {
    console.error(`Missing data file: ${DATA_PATH}. Run scripts/fetch-home-depot-places.js first.`)
    process.exit(1)
  }

  const args = process.argv.slice(2)
  const limit = args[0] ? Number(args[0]) : undefined

  /** @type {Array<any>} */
  const stores = JSON.parse(fs.readFileSync(DATA_PATH, "utf8"))
  const jobs = typeof limit === "number" && !Number.isNaN(limit) ? stores.slice(0, limit) : stores

  console.log(`Enriching ${jobs.length} stores...`)

  const browser = await chromium.launchPersistentContext(CONFIG.userDataDir, {
    channel: "msedge",
    headless: CONFIG.headless,
    viewport: { width: 1280, height: 900 },
  })

  const page = await browser.newPage()

  // Warm-up to pick up cookies/redirects
  await page.goto("https://www.homedepot.com/", {
    waitUntil: "domcontentloaded",
    timeout: 45000,
  })
  await page.waitForTimeout(3000)

  const results = []
  let updated = 0
  let skipped = 0
  let failed = 0

  for (let i = 0; i < jobs.length; i++) {
    const store = jobs[i]
    const label = store.id || `idx-${i}`
    const existingNumber = hasValidStoreNumber(store.number)
    const existingName = isSpecificName(store.name)

    if (existingNumber && existingName) {
      skipped++
      results.push(store)
      continue
    }

    const base = { ...store }
    let enriched = null

    try {
      enriched = await scrapeStoreFinder(page, store)
    } catch (err) {
      console.warn(`[${i + 1}/${jobs.length}] ${label}: StoreFinder failed (${err.message})`)
    }

    if (!enriched && hasValidStoreNumber(store.number)) {
      try {
        enriched = await scrapeStorePage(page, store)
      } catch (err) {
        console.warn(`[${i + 1}/${jobs.length}] ${label}: store page failed (${err.message})`)
      }
    }

    if (enriched && (enriched.number || enriched.name)) {
      const next = { ...base }
      if (hasValidStoreNumber(enriched.number)) next.number = formatStoreNumber(enriched.number)
      if (enriched.name && isSpecificName(enriched.name)) next.name = enriched.name.trim()
      results.push(next)
      updated++
      console.log(
        `[${i + 1}/${jobs.length}] ${label}: updated${next.name ? ` name="${next.name}"` : ""}${
          next.number ? ` #${next.number}` : ""
        }`,
      )
    } else {
      results.push(base)
      skipped++
      console.log(`[${i + 1}/${jobs.length}] ${label}: no update`)
    }

    if (i < jobs.length - 1) {
      await page.waitForTimeout(CONFIG.delayBetween)
    }
  }

  await browser.close()

  const tmpPath = `${OUT_PATH}.tmp`
  fs.writeFileSync(tmpPath, JSON.stringify(results, null, 2), "utf8")
  fs.renameSync(tmpPath, OUT_PATH)

  console.log(
    `Done. total=${jobs.length}, updated=${updated}, skipped=${skipped}, failed=${failed}. Output: ${OUT_PATH}`,
  )
}

main().catch((err) => {
  console.error("Fatal error:", err)
  process.exit(1)
})
